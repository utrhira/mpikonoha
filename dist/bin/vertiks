#!/usr/local/bin/mpikonoha

using konoha.mpi.*;
using konoha.sugar.*;

VERTIKS_HELP = ```
usage>
    $ vertiks [options] target
    target  : target task script for mpikonoha
    options :
          -np N                    -> number of mpikonoha procs
          -hostfile /path/to/file  -> mpirun hostfile path
          -host host0,host1        -> hostnames separated by comma
          --direct                 -> direct mpirun for non-task script
          --help                   -> show this help
```;

/* ------------------------------------------------------------------------ */
// System

@Public void    System.p(dynamic d)               { OUT << d << EOL }
@Public void    System.e(dynamic d)               { ERR << d << EOL }
@Public void    System.x(int i, String s)         { if (i == 0) { p(s) } else { e(s) } exit(i) }
@Public void    System.todo(String s, dynamic d)  { OUT << "TODO: " + s; p(d) }
@Public void    System.einfo(String s)            { x(0, s) }
@Public void    System.eexit(boolean b, String s) { if (!b) x(1, "failed to launch: "+ s) }
@Public boolean System.fexist(Path p)             { return (boolean)p }
@Public String  System.fload(Path p)              { b = ""; for (l : new InputStream(p)) { b += l+"\n" } return b }

/* ------------------------------------------------------------------------ */
// Options

class Options {
    Map<String,String> _optmap;
    String[] keys()                           { return _optmap.keys() }
    boolean  has(String key)                  { return key in? keys() }
    String   get(String key)                  { return _optmap[key] }
    boolean  set(String key, String val)      { _optmap[key] = val; return true }
    String   getOpt(String key)               { return (key in? keys()) ? get(key) : "" }
    boolean  setOpt(String key, String value) { return (key in? keys()) ? false : set(key, value) }
    Options(String[] args) {
        _optmap = {}
        optkey = "";
        for (arg : args) {
            if (arg[0] == "-") {
                /* set option key or single option */
                eexit(optkey == "", "option [-%s{#0}] has no value"(optkey));
                optkey = arg.replace($/^-{1,2}/, "");
                ret = true;
                switch(optkey) {
                case "n" :
                case "np" :
                case "numprocs" :  optkey = "numprocs"; break;
                case "hostfile" :  break;
                case "host" :      break;
                case "direct":     optkey = ""; ret = setOpt("direct", "enable"); break;
                case "help":       optkey = ""; einfo(VERTIKS_HELP);
                default:           eexit(false, "illegal option [-%s{#0}]"(optkey));
                }
                eexit(ret, "option [%s{#0}] is duplicated"(arg));
            }
            else if (optkey != "") {
                /* set option value */
                eexit(setOpt(optkey, arg), "option [-%s{#0}] is duplicated"(optkey));
                optkey = "";
            }
            else {
                /* set target file */
                eexit(setOpt("target", arg), "multiple target files [%s{#0}, %s{#1}]"(getOpt("target"), arg));
            }
        }
        eexit(optkey == "", "option [-%s{#0}] has no value"(optkey));
        eexit(has("target"), "no target (use '--help' for help)");
        eexit(!has("hostfile") || fexist(getOpt("hostfile")), "hostfile not found");
        eexit(fexist(getOpt("target")), "target file not found");
    }
}

/* ------------------------------------------------------------------------ */
// Token @using konoha.sugar

@Public String Token.rawText() {
    return (this.type in? [Token.TEXT2, Token.STEXT]) ? `"`+this.text+`"` : this.text;
}

// only use for Token[]
@Public String Array.tjoin() {
    ret = "";
    if (this instanceof Token[] && |this| > 0) {
        ret = this[0].text;
        if (|this| > 1) {
            for (token : this[1 to]) { ret += " " + token.rawText() }
        }
    }
    return ret;
}

// only use for Token[]
@Public Token[] Array.tuntil(Func<Token=>boolean> condf) {
    Token[] ret = [];
    if (this instanceof Token[]) {
        for (token : this) { if (condf(token)) { break } else { ret << token } }
    }
    return ret;
}

/* ------------------------------------------------------------------------ */
// TaskFunc

class TaskFunc(String fname, String param, String source) {
    String id;
    boolean tcheck(TaskScript ts, int np) {
        ret = false;
        todo("TaskFunc.tcheck", this);
        return ret;
    }
}

/* ------------------------------------------------------------------------ */
// TaskProcFunc @depends TaskFunc, TaskScript

class TaskProcFunc {
    TaskFunc tfunc;
    Map param;
    int[] ranks;
    TaskProcFunc(TaskFunc tf) {
        _tfunc = tf;
        _param = {};
        _ranks = [];
    }
    void evalParam(TaskScript ts) {
        tparam = tfunc.param;
        if (|tparam| > 0) {
            for (stt : tparam.split(",")) {
                kv = stt.trim().convert(to:lower).split("=");
                key = kv[0].trim();
                value = kv[1].trim();
                switch(key) {
                case "size":
                    ivalue = (int)value;
                    eexit(ivalue <= ts.numprocs, "target task size is too much");
                    _param[key] = ivalue;
                    break;
                case "rank":
                    ivalue = (int)value;
                    eexit(ivalue <= ts.numprocs, "specified rank over");
                    _param[key] = ivalue;
                    _ranks << ivalue;
                    break;
                case "out":
                case "err":
                    print value;
                    break;
                default: break;
                }
            }
        }
    }
    int getSize() {
        return ("size" in? _param) ? _param["size"] : 1;
    }
}

/* ------------------------------------------------------------------------ */
// TaskScript @depends TaskFunc, TaskProcFunc, Options, Token

class TaskScript {
    String target;
    int numprocs;
    Options options;
    String script;
    Map<String,TaskFunc[]> tfmap;
    Map<String,TaskProcFunc[]> tpfmap;

    TaskScript(Options opts) {
        _target  = opts.getOpt("target");
        _numprocs = (int)opts.getOpt("numprocs");
        _options = opts;
        _script = "";
        _tfmap  = {};
        _tpfmap = {};
    }

    void exec() {
        if (options.has("direct")) { // direct mpirun execution
            arg_np    = (_numprocs > 1) ? "-np " + _numprocs : "";
            arg_host  = options.has("host") ? "-host " + options.getOpt("host") : "";
            arg_hfile = options.has("hostfile") ? "-hostfile " + options.getOpt("hostfile") : "";
            cmd  = "mpirun %s{#0} %s{#1} %s{#2} mpikonoha %s{#3}"(arg_np, arg_host, arg_hfile, _target);
            OUT << System.exec(cmd);
            OUT.flush();
            exit(0);
        }
        parse();
        attach();
        run();
    }

    String regist(TaskFunc tf) {
        fname = tf.fname;
        if (fname in? _tfmap == false) _tfmap[fname] = new TaskFunc[0];
        tfary = (TaskFunc[])_tfmap[fname];
        tfid = "task["+|tfary|+"]:"+fname;
        tf.id = tfid;
        tfary << tf;
        return "/*%s{#0}*/"(tfid);
    }

    void parse() {
        tokens = Lang.tokenize(fload(_target));

        paramf = def(Token t) { return t.text == ")" }
        argsf  = def(Token t) { return (t.text != "{" && t.type != Token.CODE) }
        codef  = def(Token t) { return t.text == "}" }

        for (int i = 0; i < |tokens|; i++) {
            token = tokens[i];
            if (token.type == Token.META && token.text == "@Task") {
                fparam = "";
                j = i;
                if (tokens[++j].text == "(") {
                    tpary = tokens[++j to -1].tuntil(paramf);
                    fparam = tpary.tjoin();
                    j += (|tpary| + 1);
                }
                fname = tokens[++j].text;
                j += (|tokens[++j to -1].tuntil(argsf)| + 1);
                fsrc = "";
                if (tokens[++j].type == Token.CODE) { // this may be always true
                    fsrc = Lang.tokenize(tokens[j].text).tjoin();
                }
                else { // ***
                    tcary = tokens[++j to -1].tuntil(codef);
                    fsrc = tcary.tjoin();
                    j += (|tcary|);
                }
                tfunc = new TaskFunc(fname, fparam, fsrc);
                _script += regist(tfunc);
                i = j;
            }
            else {
                _script += token.rawText();
            }
        }
    }

    void attach() {
        for (tfname : _tfmap.keys()) {
            tfary = tfmap[tfname];
            tpfary = new TaskProcFunc[|tfary|];
            for (int i = 0; i < |tfary|; i++) {
                tpf = new TaskProcFunc(tfary[i]);
                tpf.evalParam(this);
                tpfary[i] = tpf;
            }
            _tpfmap[tfname] = tpfary;
        }
    }

    void run() {
        keys = _tpfmap.keys();
        klen = |keys|;
        for (int i = 0; i < klen; i++) {
            tpfname = keys[i];
            tpfary = (TaskProcFunc[])_tpfmap[tpfname];
            len = |tpfary|;
            pflags = new boolean[_numprocs];
            rflags = new boolean[len];
            tpsize = 0;
            for (int i = 0; i < len; i++) {
                tpf = tpfary[i];
                for (r : tpf.ranks) {
                    eexit(!pflags[r], "specified rank duplicated in [%s{#0}"(tpfname));
                    pflags[r] = true;
                    rflags[i] = true;
                }
            }
            for (int i = 0; i < len; i++) {
                tpf = tpfary[i];
                if (rflags[i]) {
                    tpsize += tpf.size;
                    continue;
                }
                eexit(tpsize + tpf.size <= _numprocs, "specified functions size in [%s{#0}]"(tpfname));
                tpranks = new int[0];
                for (int i = 0; i < tpf.size; i++) {
                    tpranks << tpsize + i;
                }
                tpranks.reshape([|tpranks|]);
                tpf.ranks = tpranks;
                tpsize += tpf.size;
            }
            for (int i = 0; i < len; i++) {
                tpf = tpfary[i];
                print tpf.tfunc.id, tpf.ranks;
            }
            print "---";
        }
    }

}

int main(String[] args)
{
    opts = new Options(args);
    task = new TaskScript(opts);
    task.exec();
    return 0;
}
