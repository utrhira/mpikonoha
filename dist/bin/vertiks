#!/usr/local/bin/mpikonoha

using konoha.mpi.*;
using konoha.sugar.*;

VERTIKS_HELP = ```
usage>
      $ vertiks [options] target
      target  : target task script for mpikonoha
      options :
            -np N                    -> number of mpikonoha procs
            -hostfile /path/to/file  -> mpirun hostfile path
            -host host0,host1        -> hostnames separated by comma
            --direct                 -> direct mpirun for non-task script
            --help                   -> show this help
```;

/* ------------------------------------------------------------------------ */
// System

@Public void    System.p(dynamic d)               { OUT << d << EOL }
@Public void    System.e(dynamic d)               { ERR << d << EOL }
@Public void    System.x(int i, String s)         { if (i == 0) { p(s) } else { e(s) } exit(i) }
@Public void    System.todo(String s, dynamic d)  { OUT << "TODO: " + s; p(d) }
@Public void    System.einfo(String s)            { x(0, s) }
@Public void    System.eexit(boolean b, String s) { if (!b) x(1, "failed to launch: "+ s) }
@Public boolean System.fexist(Path p)             { return (boolean)p }
@Public String  System.fload(Path p)              { b = ""; for (l : new InputStream(p)) { b += l+"\n" } return b }

/* ------------------------------------------------------------------------ */
// Options

class Options {
    Map<String,String> _optmap;
    String[] keys()                           { return _optmap.keys() }
    boolean  has(String key)                  { return key in? keys() }
    String   get(String key)                  { return _optmap[key] }
    boolean  set(String key, String val)      { _optmap[key] = val; return true }
    String   getOpt(String key)               { return (key in? keys()) ? get(key) : "" }
    boolean  setOpt(String key, String value) { return (key in? keys()) ? false : set(key, value) }
    Options(String[] args) {
        _optmap = {}
        optkey = "";
        for (arg : args) {
            if (arg[0] == "-") {
                /* set option key or single option */
                eexit(optkey == "", "option [-%s{#0}] has no value"(optkey));
                optkey = arg.replace($/^-{1,2}/, "");
                switch(optkey) {
                case "n" :
                case "np" :
                case "numprocs" :
                    optkey = "numprocs";
                    break;
                case "hostfile" :
                case "host" :
                    break;
                case "direct":
                    optkey = "";
                    setOpt("direct", "enable");
                    break;
                case "help":
                    optkey = "";
                    einfo(VERTIKS_HELP);
                default:
                    eexit(false, "illegal option [-%s{#0}]"(optkey));
                }
            }
            else if (optkey != "") {
                /* set option value */
                eexit(setOpt(optkey, arg), "option [-%s{#0}] is duplicated"(optkey));
                optkey = "";
            }
            else {
                /* set target file */
                eexit(setOpt("target", arg), "multiple target files [%s{#0}, %s{#1}]"(getOpt("target"), arg));
            }
        }
        eexit(optkey == "", "option [-%s{#0}] has no value"(optkey));
        eexit(has("target"), "no target (use '--help' for help)");
        eexit(!has("hostfile") || fexist(getOpt("hostfile")), "hostfile not found");
        eexit(fexist(getOpt("target")), "target file not found");
    }
}

/* ------------------------------------------------------------------------ */
// Token @using konoha.sugar

@Public String Token.rawText() {
    return (this.type in? [Token.TEXT2, Token.STEXT]) ? `"`+this.text+`"` :
           (this.type == Token.CODE) ? "{ "+this.text+" }" :
           (this.text == ";" && this.type == Token.OPERATOR) ? this.text + "\n" : this.text;

}

// only use for Token[]
String : (Token[] ta) {
    ret = "";
    if (|ta| > 0) {
        ret = ta[0].text;
        if (|ta| > 1) for (token : ta[1 to -1]) { ret += " " + token.rawText() }
    }
    return ret;
}

// only use for Token[]
@Public Token[] Array.tuntil(Func<Token=>boolean> condf) {
    Token[] ret = [];
    if (this instanceof Token[]) {
        for (token : this) { if (condf(token)) { break } else { ret << token } }
    }
    return ret;
}

// only use for int[]
String : (Array<int> ia) {
    ret = "";
    if (|ia| > 0) {
        ret = "%s"(ia[0]);
        if (|ia| > 1) for (i : ia[1 to -1]) { ret += ", " + i }
    }
    return ret;
}

/* ------------------------------------------------------------------------ */
// TaskFunc

class TaskFunc {
    String name;
    String sign;
    String sparam;
    String source;
    Map param;
    int[] ranks;
    TaskFunc(String name, String sign, String param, String source) {
        _name = name;
        _sign = sign;
        _sparam = param;
        _source = source;
        _param = {};
        _ranks = [];
    }
    void evalParam(TaskScript ts) {
        if (|_sparam| > 0) {
            for (stt : _sparam.split(",")) {
                kv = stt.trim().convert(to:lower).split("=");
                key = kv[0].trim();
                value = kv[1].trim();
                switch(key) {
                case "size" :
                    ivalue = (int)value;
                    eexit(ivalue <= ts.numprocs, "target task size is too much");
                    _param[key] = ivalue;
                    break;
                case "rank" :
                    ivalue = (int)value;
                    eexit(ivalue <= ts.numprocs, "specified rank over");
                    _param[key] = ivalue;
                    _ranks << ivalue;
                    break;
                case "out" :
                case "err" :
                    _param[key] = value;
                    todo("specified out/err of task", value);
                    break;
                default: break;
                }
            }
        }
    }
    String getId() {
        return "task:"+ this.hashCode() + "(%s{#0})"(_name);
    }
    int getSize() {
        return ("size" in? _param) ? _param["size"] :
               ("rank" in? _param) ? |_ranks| : 1;
    }
}

/* ------------------------------------------------------------------------ */
// TaskScript @depends TaskFunc, Options, Token

class TaskScript {
    String target;
    int numprocs;
    Options options;
    String script;
    Map<String,TaskFunc[]> tfmap;

    TaskScript(Options opts) {
        _target  = opts.getOpt("target");
        _numprocs = (int)opts.getOpt("numprocs");
        _options = opts;
        _script = "";
        _tfmap  = {};
    }

    void exec() {
        if (options.has("direct")) {
            /* direct mpirun execution */
            arg_np    = (_numprocs > 1) ? "-np " + _numprocs : "";
            arg_host  = options.has("host") ? "-host " + options.getOpt("host") : "";
            arg_hfile = options.has("hostfile") ? "-hostfile " + options.getOpt("hostfile") : "";
            cmd  = "mpirun %s{#0} %s{#1} %s{#2} mpikonoha %s{#3}"(arg_np, arg_host, arg_hfile, _target);
            OUT << System.exec(cmd);
            OUT.flush();
            exit(0);
        }
        parse();
        attach();
        run();
    }

    void parse() {
        tokens = Lang.tokenize(fload(_target));

        paramf = def(Token t) { return t.text == ")" }
        argsf  = def(Token t) { return (t.text != "{" && t.type != Token.CODE) }
        codef  = def(Token t) { return t.text == "}" }

        for (int i = 0; i < |tokens|; i++) {
            token = tokens[i];
            if (token.type == Token.META && token.text == "@Task") {
                fparam = "";
                j = i;
                if (tokens[++j].text == "(") {
                    tpary = tokens[++j to -1].tuntil(paramf);
                    fparam = (String)tpary;
                    j += (|tpary| + 1);
                }
                rtype = tokens[j].text;
                fname = tokens[++j].text;
                sign = "%s{#0} %s{#1}"(rtype, fname);
                for (t : tokens[++j to -1]) {
                    if (t.text == "{" || t.type == Token.CODE) break;
                    sign += " %s{#0}"(t.text);
                    j++;
                }
                fsrc = "";
                if (tokens[j].type == Token.CODE) { // this may be always true
                    fsrc = (String)Lang.tokenize(tokens[j].text);
                }
                else { // *** may be ignored
                    tcary = tokens[++j to -1].tuntil(codef);
                    fsrc = (String)tcary;
                    j += (|tcary|);
                }
                tfunc = new TaskFunc(fname, sign, fparam, fsrc);
                if (fname in? _tfmap == false) {
                    _script += "%s{#0};\n"(tfunc.sign);
                    _tfmap[fname] = new TaskFunc[0];
                }
                tfary = (TaskFunc[])_tfmap[fname];
                tfary << tfunc;
                _script += "/* %s{#0} */\n"(tfunc.id);
                i = j;
            }
            else {
                _script += token.rawText();
            }
        }
    }

    void attach() {
        for (tfname : _tfmap.keys()) {
            tfary = (TaskFunc[])tfmap[tfname];
            proc_reserved = new boolean[_numprocs];
            tf_remain = new TaskFunc[0];
            for (tf : tfary) {
                tf.evalParam(this);
                if (|tf.ranks| > 0) {
                    treserved = 0;
                    for (r : tf.ranks) {
                        eexit(!proc_reserved[r], "specified rank duplicated in [%s{#0}]"(tfname));
                        proc_reserved[r] = true;
                        treserved++;
                    }
                    if (treserved == tf.size) continue;
                }
                tf_remain << tf;
            }
            proc_remain = new int[0];
            for (int i = 0; i < _numprocs; i++) {
                if (!proc_reserved[i]) proc_remain << i;
            }
            for (tf : tf_remain) {
                tremain = tf.size - |tf.ranks|;
                for (int i = 0; i < tremain; i++) {
                    eexit(|proc_remain| > 0, "required task procs > numprocs in [%s{#0}]"(tfname));
                    r = proc_remain[0];
                    proc_remain.remove(0);
                    tf.ranks << r;
                }
            }
        }
    }

    void run() {
        tf_procs = new TaskFunc[][_numprocs];
        for (int i = 0; i < _numprocs; i++) {
            tf_procs[i] = new TaskFunc[0];
        }
        for (tfname : tfmap.keys()) {
            tfary = (TaskFunc[])_tfmap[tfname];
            for (tf : tfary) {
                for (tr : tf.ranks) {
                    tf_procs[tr] << tf;
                }
            }
        }
        pscripts = new String[_numprocs];
        phead = "";
        comms = [];
        for (int i = 0; i < _numprocs; i++) {
            tfs = (TaskFunc[])tf_procs[i];
            pscript = _script;
            for (tf : tfs) {
                pcomm = "comm_%s{#0}"("%s"(tf.hashCode()));
                if (pcomm in? comms == false) {
                    phead += "%s{#0} = MPI.setWorld(MPIComm.create([%s{#1}]));\n"(pcomm, (String)tf.ranks);
                    comms << pcomm;
                }
                tscript = "%s{#0}\n{\nMPIComm.setWorld(%s{#1});\n%s{#2}MPIComm.resetWorld();\n}"(tf.sign, pcomm, tf.source);
                pscript = pscript.replace("/* %s{#0} */"(tf.id), tscript);
            }
            pscripts[i] = pscript;
        }
        for (int i = 0; i < _numprocs; i++) {
            pscript = pscripts[i];
            task_proc_script = phead + "\n" + pscript;
            OUT.println(task_proc_script);
        }
    }

}

int main(String[] args)
{
    opts = new Options(args);
    task = new TaskScript(opts);
    task.exec();
    return 0;
}
